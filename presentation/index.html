<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Kniffel</title>
  <link rel="stylesheet" href="dist/reset.css">
  <link rel="stylesheet" href="dist/reveal.css">
  <link rel="stylesheet" href="dist/theme/night.css">
  <link rel="icon" href="assets/" type="image/x-icon">
  <link rel="stylesheet" href="plugin/highlight/monokai.css">
  <link rel="stylesheet" href="plugin/highlight/zenburn.css">
  <style>
    .reveal .slides section .fragment.highlight-current-red.current-fragment {
      color: #ff6b6b;
    }
    body, .reveal, .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5, .reveal h6 {
      font-family: 'Source Sans Pro', Helvetica, Arial, sans-serif !important;
      font-weight: 400;
    }
    .reveal h1 {
      font-size: 2.2em !important;
      font-weight: 700;
      margin-bottom: 0.2em;
      letter-spacing: 0.01em;
    }
    .reveal h3 {
      font-size: 1.2em !important;
      font-weight: 400;
      margin-bottom: 1.2em;
      letter-spacing: 0.01em;
    }
    .tech-stack {
      display: flex;
      justify-content: space-around;
      align-items: center;
      margin: 20px 0;
    }
    .tech-item {
      text-align: center;
      margin: 0 10px;
    }
    .game-rules {
      font-size: 0.8em;
      text-align: left;
    }
    .architecture-diagram {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 20px 0;
    }
    .layer {
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 10px;
      margin: 0 10px;
      flex: 1;
    }
    .checklist {
      list-style: none !important;
      padding-left: 0;
      margin-left: 0;
    }
    .checklist li {
      list-style: none !important;
      margin-left: 0;
      padding-left: 0.5em;
      position: relative;
    }
    .checklist li::before {
      content: "‚úî ";
      color: #4caf50;
      font-weight: bold;
    }
    .challenge-solution {
      display: flex;
      gap: 40px;
      flex-wrap: wrap;
    }
    .challenge-solution > div {
      flex: 1 1 300px;
      min-width: 250px;
    }
    .architecture-diagram {
      display: flex;
      justify-content: space-between;
      align-items: stretch;
      margin: 20px 0;
      gap: 1em;
    }
    .layer {
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 10px;
      margin: 0 10px;
      flex: 1 1 0;
      min-width: 220px;
      min-height: 180px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    .reveal {
    background: #18243a !important; /* Sattes Dunkelblau */
    }
    .reveal .slides {
      background: transparent !important;
    }
    .reveal, .reveal .slides, .reveal section {
      color: #e6eaf3 !important;
    }
    .reveal h1, .reveal h2, .reveal h3 {
      margin-bottom: 0.5em;
      letter-spacing: 0.01em;
    }
    .reveal ul, .reveal ol {
      font-size: 0.97em;
      margin-bottom: 0.5em;
    }
    .reveal pre code {
      font-size: 0.92em;
      border-radius: 8px;
      background: #232e47 !important;
      color: #e6eaf3 !important;
      padding: 1em;
    }
    figcaption {
      color: #b0b8c9;
      font-size: 0.95em;
      margin-top: 0.3em;
    }
    .checklist li::before {
      color: #4fc3f7;
    }
    .fragment {
      transition: opacity 0.5s, transform 0.5s;
    }
    .team-roles {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 2em;
    margin-bottom: 1em;
    align-items: stretch;
    width: 100%;
  }
  .team-roles > div {
    min-width: 260px;
    max-width: 340px;
    font-size: 0.82em;
    flex: 1 1 0;
    background: rgba(255,255,255,0.07);
    border-radius: 12px;
    padding: 1em 1.2em 1em 1.2em;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    font-size: 0.92em;
    overflow: visible;
    word-break: break-word;
    overflow-wrap: break-word;
    hyphens: auto;
    height: auto;
  }
  .team-roles h4 {
    margin-top: 0;
    margin-bottom: 0.5em;
    font-size: 1em;
    font-weight: 700;
    color: #4fc3f7;
    white-space: normal;
  }
  .team-roles ul {
    margin: 0;
    padding-left: 1.1em;
    font-size: 0.8em;
    list-style: disc;
    color: #e6eaf3;
  }
  .team-roles li {
    margin-bottom: 0.18em;
    line-height: 1.22;
  }
  @media (max-width: 1100px) {
    .team-roles {
      flex-direction: column;
      align-items: stretch;
      gap: 1em;
    }
    .team-roles > div {
      width: 100%;
      min-width: 0;
      max-width: 100vw;
    }
  }
  </style>
</head>
<body>
  <div class="reveal">
    <div class="slides">
      
      <!-- Title Slide -->
      <section>
        <h1 style="font-size:2.5em;font-family:'Source Sans Pro',Helvetica,sans-serif;margin-bottom:0.3em;">üé≤ Kniffel Web-App</h1>
        <h3 style="font-size:1.3em;font-family:'Source Sans Pro',Helvetica,sans-serif;margin-bottom:1em;">Online W√ºrfelspiel mit Registrierung & Highscore</h3>
        <p>
          <small>Entwickelt von: Camille, Lars & Lukas</small>
        </p>
        <aside class="notes">
          <strong>Lukas:</strong>
          <ul>
            <li>Willkommen zu unserer Pr√§sentation der Kniffel Web-App.</li>
            <li>Das Team: Camille, Lars und ich, Lukas.</li>
          </ul>
        </aside>
      </section>

      <!-- Gliederung -->
      <section>
        <h2>üìã Gliederung</h2>
        <ol>
          <li class="fragment fade-in-then-semi-out">Muss-Kriterien</li>
          <li class="fragment fade-in-then-semi-out">Technik√ºbersicht</li>
          <li class="fragment fade-in-then-semi-out">Projektstruktur</li>
          <li class="fragment fade-in-then-semi-out">Screenshots</li>
          <li class="fragment fade-in-then-semi-out">Code-Implementierung</li>
          <li class="fragment fade-in-then-semi-out">Aufgabenverteilung</li>
          <li class="fragment fade-in-then-semi-out">Herausforderungen & Reflexion</li>
          <li class="fragment fade-in-then-semi-out">Live Demo</li>
        </ol>
        <aside class="notes">
          <strong>Lars:</strong>
          <ul>
            <li>Hier seht ihr die Gliederung unserer Pr√§sentation.</li>
            <li>Wir starten mit den Muss-Kriterien, geben einen √úberblick √ºber die Technik und die Projektstruktur.</li>
            <li>Danach zeigen wir Screenshots, gehen auf die Code-Implementierung ein, verteilen die Aufgaben, sprechen √ºber Herausforderungen und zeigen eine Live-Demo.</li>
          </ul>
        </aside>
      </section>

      <!-- Muss-Kriterien Checkliste -->
      <section>
        <h2>‚úÖ Muss-Kriterien</h2>
        <ul class="checklist">
          <li class="fragment">Registrierung & Login/Logout</li>
          <li class="fragment">Kniffel-Spiel mit 5 W√ºrfeln, 3 W√ºrfen, W√ºrfel halten</li>
          <li class="fragment">Automatische Punktevergabe & Kategorien</li>
          <li class="fragment">Spielstand speichern & Highscore-Liste</li>
          <li class="fragment">Eigene Spielhistorie</li>
        </ul>
        <aside class="notes">
          <strong>Lukas:</strong> 
          <p>Hier seht ihr die wichtigsten Muss-Kriterien, die wir umgesetzt haben.</p>
          <ol>
            <li>Erstens: Jeder Nutzer kann sich registrieren, einloggen und auch wieder ausloggen.</li>
            <li>Zweitens: Das eigentliche Kniffel-Spiel l√§uft mit 5 W√ºrfeln, pro Runde darf man bis zu 3-mal w√ºrfeln und beliebige W√ºrfel halten.</li>
            <li>Drittens: Die Punkte werden automatisch berechnet und den richtigen Kategorien zugeordnet, sodass niemand selbst rechnen muss.</li>
            <li>Viertens: Nach jedem Spiel wird der Spielstand gespeichert und die Highscore-Liste aktualisiert.</li>
            <li>Und schlie√ülich kann jeder Nutzer seine eigene Spielhistorie einsehen, also alle bisherigen Spiele und deren Ergebnisse.</li>
          </ol>
        </aside>
      </section>

      <!-- Technik√ºbersicht -->
      <section>
        <h2>‚öô Technik√ºbersicht</h2>
        <div class="architecture-diagram" style="gap:1em;">
          <div class="layer fragment">
            <h4>Frontend</h4>
            <ul>
              <li>React + Vite</li>
              <li>Tailwind CSS</li>
              <li>JavaScript ES6+</li>
            </ul>
          </div>
          
          <div class="layer fragment">
            <h4>Backend</h4>
            <ul>
              <li>Node.js + Express</li>
              <li>Session-Auth</li>
              <li>RESTful API</li>
            </ul>
          </div>

          <div class="layer fragment">
            <h4>Datenbank</h4>
            <ul>
              <li>SQLite</li>
              <li>Prisma ORM</li>
             <li>Migrations</li>
            </ul>
          </div>
        </div>
        <aside class="notes">
          <strong>Lukas:</strong>
          <ul>
            <li>F√ºr die Umsetzung haben wir moderne Technologien gew√§hlt.</li>
            <li>Im Frontend setzen wir auf React mit Vite f√ºr schnelle Entwicklung und Tailwind CSS f√ºr das Styling.</li>
            <li>Die Spiellogik und die Interaktivit√§t laufen komplett im Browser mit JavaScript ES6+.</li>
            <li>Im Backend nutzen wir Node.js mit Express, um eine REST-API bereitzustellen.</li>
            <li>Die Authentifizierung l√§uft √ºber Sessions, damit Nutzer sicher eingeloggt bleiben.</li>
            <li>F√ºr die Datenhaltung verwenden wir SQLite als Datenbank und Prisma als ORM, um einfach und sicher auf die Daten zuzugreifen und Migrationen durchzuf√ºhren.</li>
          </ul>
        </aside>
      </section>

      <!-- Projektstruktur -->
      <section>
        <section>
          <h2>üìÅ Projektstruktur</h2>
          <p>Klare Trennung zwischen Frontend und Backend</p>
          <aside class="notes">
            <strong>Camille:</strong>
            <ul>
              <li>Die Projektstruktur ist klar getrennt:</li>
              <li>Das Frontend und das Backend sind jeweils in eigenen Ordnern organisiert.</li>
              <li>Das erleichtert die Entwicklung, weil jeder Bereich unabh√§ngig weiterentwickelt und getestet werden kann.</li>
              <li>Gerade f√ºr das Backend war es wichtig, eine saubere Struktur zu haben, damit die API, die Datenbank und die Authentifizierung √ºbersichtlich und wartbar bleiben.</li>
              <li>So konnten wir √Ñnderungen schnell umsetzen und Fehler leichter finden.</li>
            </ul>
          </aside>
        </section>

        <section>
          <h3>Backend Struktur</h3>
          <pre><code class="language-js" data-trim>
server/
‚îú‚îÄ‚îÄ index.js            // App-Startpunkt
‚îú‚îÄ‚îÄ routes/             // API-Routen
‚îú‚îÄ‚îÄ middleware/         // Authentifizierung & Fehlerbehandlung
‚îú‚îÄ‚îÄ prisma/             // Datenbank & Schema
‚îú‚îÄ‚îÄ utils/              // Hilfsfunktionen
‚îî‚îÄ‚îÄ .env                // Umgebungsvariablen
          </code></pre>
          <aside class="notes">
            <strong>Lars:</strong>
            <ul>
              <li>Im Backend gibt es einen zentralen Einstiegspunkt, die index.js.</li>
              <li>Die API-Routen sind in einem eigenen Verzeichnis organisiert, zum Beispiel f√ºr Authentifizierung und Score.</li>
              <li>Die Middleware enth√§lt Funktionen f√ºr Authentifizierung und Fehlerbehandlung.</li>
              <li>Im prisma-Ordner liegt das Datenbankschema und die Migrationen.</li>
              <li>Hilfsfunktionen, zum Beispiel f√ºr die Validierung, sind in utils ausgelagert.</li>
              <li>Die Umgebungsvariablen wie Datenbankpfad oder Session-Secret stehen in der .env-Datei.</li>
            </ul>
          </aside>
        </section>

        <section>
          <h3>Frontend Struktur</h3>
            <pre><code data-trim>
client/
‚îú‚îÄ‚îÄ src/                // React-Quellcode
‚îÇ   ‚îú‚îÄ‚îÄ components/     // UI-Komponenten
‚îÇ   ‚îú‚îÄ‚îÄ pages/          // Seiten
‚îÇ   ‚îú‚îÄ‚îÄ utils/          // Logik
‚îú‚îÄ‚îÄ public/             // Statische Assets
‚îú‚îÄ‚îÄ index.html          // HTML-Template
‚îî‚îÄ‚îÄ vite.config.js      // Vite-Konfiguration
            </code></pre>
            <aside class="notes">
              <strong>Lukas:</strong>
              <ul>
                <li>Das Frontend ist ebenfalls klar strukturiert.</li>
                <li>Im src-Ordner liegen alle React-Komponenten, die einzelnen Seiten und die Hilfsfunktionen.</li>
                <li>Die Komponenten sind wiederverwendbare UI-Bausteine, zum Beispiel f√ºr die W√ºrfel oder das Scoreboard.</li>
                <li>Die Seiten bilden die verschiedenen Ansichten ab, wie das Spiel, die Highscore-Liste oder die Registrierung.</li>
                <li>Im public-Ordner liegen statische Dateien wie Bilder.</li>
                <li>Die index.html ist das HTML-Template, das von Vite beim Build verwendet wird.</li>
                <li>Die Vite-Konfiguration steuert den Entwicklungsserver und das Build-Verhalten.</li>
              </ul>
            </aside>
        </section>
      </section>

      <!-- Screenshots -->
      <section>
        <section>
          <h2>üñºÔ∏è ScreenshotsÔ∏è</h2>
          <p>Wichtige Ansichten der App</p>
          <aside class="notes">
            <strong>Camille:</strong> Wir zeigen euch jetzt ein paar Screenshots, damit ihr einen Eindruck von der App bekommt. 
          </aside>
        </section>

        <section>
          <h3>Registrierung & Login</h3>
          <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 2em;">
            <figure>
              <img src="../assets/register.png" alt="Registrieren" style="max-width: 350px; max-height: 350px;">
            </figure>
            <figure>
              <img src="../assets/login.png" alt="Login" style="max-width: 350px; max-height: 350px;">
            </figure>
          </div>
          <aside class="notes">
            <strong>Lars:</strong>
            <ul>
              <li>Hier seht ihr die Registrierung und den Login.</li>
              <li>Die Formulare sind bewusst einfach gehalten, damit man schnell starten kann.</li>
              <li>Nach erfolgreicher Registrierung ist man direkt eingeloggt und kann losspielen.</li>
              <li>Die Authentifizierung l√§uft √ºber Sessions, sodass man auch nach einem Neuladen der Seite eingeloggt bleibt.</li>
            </ul>
          </aside>
        </section>

        <section>
          <h3>Spieloberfl√§che</h3>
          <div style="display: flex; justify-content: center;">
            <figure>
              <img src="../assets/game.png" alt="Spiel" style="max-width: 350px; max-height: 350px;">
            </figure>
          </div>
          <aside class="notes">
            <strong>Lukas:</strong>
            <ul>
              <li>Das ist die Hauptspieloberfl√§che.</li>
              <li>Oben sieht man die aktuellen W√ºrfel, darunter die Buttons zum W√ºrfeln und Halten.</li>
              <li>Die Kategorien und die aktuellen Punkte werden √ºbersichtlich angezeigt.</li>
              <li>Die Punkte werden automatisch berechnet und angezeigt, sobald alle W√ºrfel geworfen wurden.</li>
            </ul>
          </aside>
        </section>

        <section>
          <h3>Highscore</h3>
          <div style="display: flex; justify-content: center;">
            <figure>
              <img src="../assets/highscore.png" alt="Highscore" style="max-width: 350px; max-height: 350px;">
            </figure>
          </div>
          <aside class="notes">
            <strong>Camille:</strong>
            <ul>
              <li>Die Highscore-Liste zeigt die besten 10 Spieler mit ihren Punktzahlen.</li>
              <li>Nach jedem Spiel wird der Score automatisch gespeichert und die Liste aktualisiert.</li>
              <li>So kann man sich mit anderen messen und sieht direkt, wie gut man war.</li>
            </ul>
          </aside>
        </section>

        <section>
          <h3>Regeln</h3>
          <div style="display: flex; justify-content: center;">
            <figure>
              <img src="../assets/rules.png" alt="Regeln" style="max-width: 350px; max-height: 350px;">
            </figure>
          </div>
          <aside class="notes">
            <strong>Lars:</strong>
            <ul>
              <li>F√ºr Neueinsteiger gibt es eine eigene Seite mit allen Kniffel-Regeln.</li>
              <li>Hier sind alle Kategorien und die jeweiligen Punktebedingungen erkl√§rt.</li>
              <li>So kann jeder sofort loslegen, auch wenn er das Spiel noch nicht kennt.</li>
            </ul>
          </aside>
        </section>
      </section>

      <!-- Code-Implementierung -->
      <section>
        <section>
          <h2>üíª Code-Implementierung</h2>
          <p>Wichtigste Funktionen im Frontend & Backend ‚Äì mit Codebeispielen</p>
          <aside class="notes">
            <strong>Lukas:</strong>
            <ul>
              <li>Wir zeigen euch jetzt die wichtigsten technischen L√∂sungen ‚Äì getrennt nach Frontend und Backend.</li>
              <li>Zu jedem Thema gibt es ein konkretes Codebeispiel und eine kurze Erkl√§rung.</li>
            </ul>
          </aside>
        </section>

        <!-- Frontend: State Management & W√ºrfeln -->
        <section>
          <h3>Frontend: State Management & W√ºrfeln</h3>
          <pre><code class="language-js" data-trim>
const [dice, setDice] = useState(Array(5).fill(null));
const [kept, setKept] = useState(Array(5).fill(false));
const [rollsLeft, setRollsLeft] = useState(3);

function rollDie() {
  return Math.floor(Math.random() * 6) + 1;
}

function rollDice() {
  if (rollsLeft === 0) return;
  setDice(dice.map((d, i) => (kept[i] && d !== null ? d : rollDie())));
  setRollsLeft(rollsLeft - 1);
}
          </code></pre>
          <aside class="notes">
            <strong>Lars:</strong>
            <ul>
              <li>Wir speichern die W√ºrfel, gehaltene W√ºrfel und die W√ºrfe im State.</li>
              <li>Mit <code>rollDice</code> werden alle nicht gehaltenen W√ºrfel neu geworfen.</li>
              <li>Die Anzahl der W√ºrfe wird automatisch reduziert.</li>
            </ul>
          </aside>
        </section>

        <!-- Frontend: Punkteberechnung -->
        <section>
          <h3>Frontend: Punkteberechnung</h3>
          <pre><code class="language-js" data-trim>
        export function calculateScore(category, dice) {
          const counts = [0, 0, 0, 0, 0, 0];
          dice.forEach((d) => counts[d - 1]++);
          switch (category) {
            // Punkte f√ºr die einzelnen Kategorien
            case "Sixes": {
              const num = ["Ones","Twos","Threes","Fours","Fives","Sixes"].indexOf(category) + 1;
              return dice.filter((d) => d === num).reduce((a, b) => a + b, 0);
            }
            case "Three of a Kind":
              return counts.some((c) => c >= 3) ? sum(dice) : 0;
            // case "Four of a Kind" wie "Three of a Kind", aber mit 4 W√ºrfeln
            case "Full House":
              return counts.includes(3) && counts.includes(2) ? 25 : 0;
            case "Small Straight":
              return hasStraight(counts, 4) ? 30 : 0;
            // case "Large Straight" wie "Small Straight", aber mit 5 W√ºrfeln
            case "Kniffel":
              return counts.includes(5) ? 50 : 0;
            case "Chance":
              return sum(dice);
            default:
              return 0;
          }
        }
          </code></pre>
          <aside class="notes">
            <strong>Lars:</strong>
            <ul>
              <li>Die Funktion <code>calculateScore</code> berechnet die Punkte f√ºr jede Kniffel-Kategorie.</li>
              <li>F√ºr jede Kategorie gibt es eine eigene Regel, z.B. z√§hlt bei "Three of a Kind" die Summe aller W√ºrfel, wenn mindestens drei gleich sind.</li>
              <li>Auch Spezialf√§lle wie Full House, Kniffel oder Chance werden hier abgedeckt.</li>
              <li>Die Funktion <code>sum</code> hilft dabei, die Augensumme zu berechnen.</li>
              <li>So wird sichergestellt, dass die Punktevergabe immer korrekt und automatisch erfolgt.</li>
            </ul>
          </aside>
        </section>

        <!-- Frontend: Stra√üen-Erkennung -->
        <section>
          <h3>Frontend: Stra√üen-Erkennung</h3>
          <pre><code class="language-js" data-trim>
export function hasStraight(counts, length) {
  const binary = counts.map((c) => (c > 0 ? 1 : 0)).join("");
  const patterns = { 4: ["1111", "01111", "11110"], 5: ["11111"] };
  return patterns[length].some((p) => binary.includes(p));
}
          </code></pre>
          <aside class="notes">
            <strong>Lars:</strong>
            <ul>
              <li>Die Funktion <code>hasStraight</code> pr√ºft, ob eine kleine oder gro√üe Stra√üe geworfen wurde.</li>
              <li>Dazu wird gez√§hlt, welche Augenzahlen mindestens einmal vorkommen und als Bin√§rstring dargestellt.</li>
              <li>Mit Pattern-Matching wird dann erkannt, ob die passenden Zahlenfolgen f√ºr eine Stra√üe vorhanden sind.</li>
              <li>Das ist effizient und verhindert Fehler bei der Stra√üenerkennung.</li>
              <li>So werden kleine und gro√üe Stra√üen im Spiel automatisch erkannt und korrekt gewertet.</li>
            </ul>
          </aside>
        </section>

        <!-- Frontend: Live Score Vorschau & Automatisches Speichern -->
        <section>
          <h3>Frontend: Live Score Vorschau & Automatisches Speichern</h3>
          <pre><code class="language-js" data-trim>
const previewScore = !isChosen && allRolled ? calculateScore(cat, dice) : null;

useEffect(() => {
  if (!isGameComplete) return;
  const totalScore = ...;
  axios.post("/api/score", { value: totalScore }, { withCredentials: true });
}, [isGameComplete, scores, user]);
          </code></pre>
          <aside class="notes">
            <strong>Lars:</strong>
            <ul>
              <li>Die Live Score Vorschau zeigt direkt die m√∂glichen Punkte an.</li>
              <li>Nach Spielende wird der Score automatisch an das Backend gesendet.</li>
              <li>Das passiert per API-Call mit Axios.</li>
            </ul>
          </aside>
        </section>

        <!-- Backend: Session-Authentifizierung & Registrierung -->
        <section>
          <h3>Backend: Session-Authentifizierung & Registrierung</h3>
          <pre><code class="language-js" data-trim>
router.post("/register", asyncHandler(async (req, res) => {
  const { username, password } = req.body;
  const hash = await bcrypt.hash(password, 10);
  const user = await prisma.user.create({ data: { username, password: hash } });
  req.session.userId = user.id;
  res.json({ success: true });
}));
          </code></pre>
          <aside class="notes">
            <strong>Camille:</strong>
            <ul>
              <li>Bei der Registrierung wird das Passwort sicher gehasht, damit es nicht im Klartext in der Datenbank landet.</li>
              <li>Der User wird in der Datenbank gespeichert, und wir pr√ºfen, ob der Benutzername schon vergeben ist.</li>
              <li>Nach erfolgreicher Registrierung wird die Session gesetzt, damit der Nutzer direkt eingeloggt ist und keine erneute Anmeldung n√∂tig ist.</li>
              <li>Das sorgt f√ºr eine sichere und komfortable Nutzererfahrung.</li>
              <li>Die gleiche Logik nutzen wir auch beim Login, um die Authentifizierung zu pr√ºfen.</li>
            </ul>
          </aside>
        </section>

        <!-- Backend: Score speichern -->
        <section>
          <h3>Backend: Score speichern</h3>
          <pre><code class="language-js" data-trim>
router.post("/score", isAuthenticated, asyncHandler(async (req, res) => {
  const { value } = req.body;
  await prisma.score.create({ data: { value, userId: req.session.userId } });
  res.json({ success: true });
}));
          </code></pre>
          <aside class="notes">
            <strong>Camille:</strong>
            <ul>
              <li>Nach Spielende wird der Score per POST-Request gespeichert.</li>
              <li>Die User-ID kommt aus der Session, so ist der Score eindeutig dem eingeloggten Nutzer zugeordnet.</li>
              <li>Wir speichern nicht nur den Score, sondern auch das Datum, damit wir sp√§ter die Historie und Statistiken berechnen k√∂nnen.</li>
              <li>Die Antwort ist ein einfacher Erfolgsstatus, damit das Frontend wei√ü, dass alles geklappt hat.</li>
              <li>Fehler werden zentral abgefangen und als JSON zur√ºckgegeben, damit der Client sie anzeigen kann.</li>
            </ul>
          </aside>
        </section>

        <!-- Backend: Highscores abrufen -->
        <section>
          <h3>Backend: Highscores abrufen</h3>
          <pre><code class="language-js" data-trim>
router.get("/highscores", asyncHandler(async (req, res) => {
  const scores = await prisma.score.findMany({
    orderBy: { value: "desc" },
    take: 10,
    include: { user: true }
  });
  res.json(scores);
}));
          </code></pre>
          <aside class="notes">
            <strong>Camille:</strong>
            <ul>
              <li>Die Highscore-Liste liefert die besten 10 Scores mit Usernamen.</li>
              <li>Sortierung erfolgt absteigend nach Score, damit immer die h√∂chsten Ergebnisse oben stehen.</li>
              <li>Wir nutzen ein Join mit der User-Tabelle, um die Namen der Spieler anzuzeigen.</li>
              <li>Das Ergebnis wird als JSON zur√ºckgegeben und im Frontend angezeigt.</li>
              <li>So k√∂nnen sich die Nutzer direkt mit anderen vergleichen und sehen, wie sie im Ranking stehen.</li>
            </ul>
          </aside>
        </section>

        <!-- Backend: Eigene Historie & Statistiken -->
        <section>
          <h3>Backend: Eigene Historie & Statistiken</h3>
          <pre><code class="language-js" data-trim>
router.get("/my-history", isAuthenticated, asyncHandler(async (req, res) => {
  const history = await prisma.score.findMany({
    where: { userId: req.session.userId },
    orderBy: { date: "desc" },
  });
  res.json(history);
}));

router.get("/my-stats", isAuthenticated, asyncHandler(async (req, res) => {
  const scores = await prisma.score.findMany({ where: { userId: req.session.userId } });
  const avgScore = scores.length
    ? Math.round(scores.reduce((sum, score) => sum + score.value, 0) / scores.length)
    : 0;
  res.json({ gamesPlayed: scores.length, avgScore });
}));
          </code></pre>
          <aside class="notes">
            <strong>Camille:</strong>
            <ul>
              <li>Die API liefert die eigene Spielhistorie und Statistiken wie Durchschnitt und Anzahl der Spiele.</li>
              <li>Wir filtern die Scores nach der User-ID aus der Session, damit jeder nur seine eigenen Daten sieht.</li>
              <li>Die Daten werden direkt aus der Datenbank berechnet und als JSON zur√ºckgegeben.</li>
              <li>Das Frontend kann daraus eine √úbersicht und Auswertungen anzeigen, zum Beispiel den pers√∂nlichen Fortschritt.</li>
              <li>So bekommt jeder Nutzer einen guten √úberblick √ºber seine bisherigen Spiele und Erfolge.</li>
            </ul>
          </aside>
        </section>
      </section>

      <!-- Aufgabenverteilung -->
      <section>
        <h2>üë• Aufgabenverteilung</h2>
        <div class="team-roles">
          <div>
            <h4>Camille</h4>
            <ul>
              <li>Backend-Entwicklung</li>
              <li>Datenbank-Design</li>
              <li>API-Endpoints</li>
              <li>Authentifizierung</li>
            </ul>
          </div>
          <div>
            <h4>Lars</h4>
            <ul>
              <li>Frontend-Entwicklung</li>
              <li>Spiellogik</li>
              <li>React Components</li>
              <li>UI/UX Design</li>
            </ul>
          </div>
          <div>
            <h4>Lukas</h4>
            <ul>
              <li>Testing & Debugging</li>
              <li>Styling & Layout</li>
              <li>Dokumentation</li>
              <li>Deployment</li>
            </ul>
          </div>
        </div>
        <aside class="notes">
          <strong>Lukas:</strong>
          <ul>
            <li>Die Aufgaben waren klar verteilt:</li>
            <li>Camille hat das Backend entwickelt, das Datenbankmodell entworfen und die API-Endpunkte gebaut.</li>
            <li>Lars war f√ºr das Frontend, die Spiellogik und das UI/UX-Design zust√§ndig.</li>
            <li>Ich habe mich um Testing, Styling, Dokumentation und das Deployment gek√ºmmert.</li>
            <li>Durch diese klare Aufteilung konnten wir effizient arbeiten und uns gegenseitig unterst√ºtzen.</li>
          </ul>
        </aside>
      </section>

      <!-- Herausforderungen & Reflexion -->
      <section>
        <section>
          <h2>‚ö† Herausforderungen & Reflexion</h2>
          <ul>
            <li class="fragment">Stra√üen-Erkennung (Bin√§r-Pattern-Matching)</li>
            <li class="fragment">Komplexes State Management im Frontend</li>
            <li class="fragment">Session-Handling & sichere Authentifizierung</li>
            <li class="fragment">Score-User-Verkn√ºpfung in der Datenbank</li>
          </ul>
          <aside class="notes">
            <strong>Lars:</strong>
            <ul>
              <li>Wir hatten einige technische Herausforderungen, z.B. die algorithmische Erkennung von kleinen und gro√üen Stra√üen.</li>
              <li>Das State Management im Frontend war anspruchsvoll, weil viele Zust√§nde (W√ºrfel, Kategorien, Scores) synchronisiert werden mussten.</li>
              <li>Im Backend war das sichere Session-Handling und die Authentifizierung wichtig.</li>
              <li>Au√üerdem mussten Scores eindeutig dem richtigen User zugeordnet werden.</li>
            </ul>
          </aside>
        </section>
        <section>
          <h3>Unsere L√∂sungen & Learnings</h3>
          <ul>
            <li class="fragment">Effiziente Algorithmen & klare Struktur</li>
            <li class="fragment">Automatisches Speichern & Live-Vorschau</li>
            <li class="fragment">Middleware & zentrale Fehlerbehandlung</li>
            <li class="fragment">Gute Teamarbeit, alle Kernfunktionen umgesetzt</li>
            <li class="fragment">Moderne Technologien & saubere Entwicklung</li>
          </ul>
          <aside class="notes">
            <strong>Camille:</strong>
            <ul>
              <li>Wir haben effiziente Algorithmen wie das Bin√§r-Pattern-Matching f√ºr Stra√üen genutzt.</li>
              <li>Das automatische Speichern und die Live-Vorschau im Frontend verbessern die Nutzererfahrung.</li>
              <li>Im Backend sorgen Middleware und zentrale Fehlerbehandlung f√ºr Sicherheit und Wartbarkeit.</li>
              <li>Durch gute Teamarbeit konnten wir alle Kernfunktionen erfolgreich umsetzen.</li>
              <li>Die Wahl moderner Technologien hat uns eine saubere und strukturierte Entwicklung erm√∂glicht.</li>
            </ul>
          </aside>
        </section>
      </section>

      <!-- Live Demo -->
      <section>
        <h2>üöÄ Live Demo</h2>
        <h3>Funktionen in Aktion</h3>
        <ol>
          <li class="fragment">Benutzer registrieren</li>
          <li class="fragment">Kniffel spielen</li>
          <li class="fragment">Score speichern</li>
          <li class="fragment">Highscore anzeigen</li>
          <li class="fragment">Eigene Spielhistorie ansehen</li>
        </ol>
        <aside class="notes">
          <strong>Camille:</strong>
          <ul>
            <li>Jetzt zeigen wir die App live.</li>
            <li>Wir registrieren einen neuen Nutzer, spielen eine Runde Kniffel, speichern den Score und schauen uns die Highscore-Liste und die eigene Spielhistorie an.</li>
            <li>So seht ihr alle wichtigen Funktionen in Aktion.</li>
          </ul>
        </aside>
      </section>

      <!-- Ende -->
      <section>
        <h2>üéâ Danke f√ºr die Aufmerksamkeit!</h2>
        <p>Fragen?</p>
        <p style="margin-top:2em;"><small>GitHub & Projektlink auf Anfrage</small></p>
        <aside class="notes">
          <strong>Camille:</strong> Vielen Dank f√ºr die Aufmerksamkeit! Wir freuen uns auf euer Feedback.
        </aside>
      </section>
    </div>
  </div>

  <script src="dist/reveal.js"></script>
  <script src="plugin/notes/notes.js"></script>
  <script src="plugin/markdown/markdown.js"></script>
  <script src="plugin/highlight/highlight.js"></script>

  <script>
    Reveal.initialize({
      hash: true,
      plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ],
      transition: 'slide',
      transitionSpeed: 'default',
      backgroundTransition: 'fade',
    });
  </script>
</body>
</html>